{"0": {
    "doc": "Apalache vs TLC",
    "title": "Apalache vs TLC",
    "content": "In ‘Hello World’ we used TLC to model check a simple model. Both model checkers have advantages and disadvantages. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/apalache_vs_tlc.html",
    "relUrl": "/docs/tla_basics_tutorials/apalache_vs_tlc.html"
  },"1": {
    "doc": "Apalache vs TLC",
    "title": "Apalache",
    "content": "Apalache is a bounded symbolic model checker. Apalache will transform your Init and Next boolean functions into a logical formula which can be solved using an SMT solver. The formula is a conjunction of smaller formulas, one for each step of the system. This means Apalache requires a parameter k specifying how many steps it should explore, starting from Init. The advantage of Apalache’s approach is that it can deal with some infinite state spaces. For example it can solve the constraint problem (x is integer) /\\ (0 &lt;= x) /\\ (x &lt; 2^32) very easily - providing concrete values of x that satisfy the constraints. Can you see how this may be useful for modelling financial transaction software? . The disadvantage of Apalache’s approach is that it can not easily check executions which take many steps from Init. This is because the formula grows for each step in the execution, becoming progressively more difficult to solve with an SMT solver. In practice 6-12 steps may be achievable in a reasonable time, depending on the model. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/apalache_vs_tlc.html#apalache",
    "relUrl": "/docs/tla_basics_tutorials/apalache_vs_tlc.html#apalache"
  },"2": {
    "doc": "Apalache vs TLC",
    "title": "TLC",
    "content": "TLC is an explicit state enumeration model checker. TLC will perform a breadth first search of the state space starting from the Init state. Each explored state is fingerprinted and the fingerprint is stored. When a state is processed from the queue (BFS style) TLC will only explore its successor states if its fingerprint has not been seen before. The advantage of TLC’s approach is that it can check unbounded length executions. In particular, if there are finitely many possible system states, TLC can enumerate all of them. In practice it is possible to check billions of states, the only limit is storage (to store the BFS queue and the fingerprints) and time. In practice TLC is fast when it can use only RAM but will become extremely slow if it runs out of memory and has to store data on disk. The disadvantage of TLC’s approach is that it must enumerate states explicitly and cannot solve symbolic constraints. For example if x can feasibly take values in [1, 2^32] then TLC will have to check a state for each value. How many states will TLC have to check if (x, y) can both take values in [1, 2^32]? . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/apalache_vs_tlc.html#tlc",
    "relUrl": "/docs/tla_basics_tutorials/apalache_vs_tlc.html#tlc"
  },"3": {
    "doc": "Apalache vs TLC",
    "title": "Feature asymmetry",
    "content": "There are features that TLC has and Apalache does’t and vice versa. [Coming soon! TODO: link to an Apalache vs TLC page with a detailed discussion] . In this tutorial we focus on Apalache, and particularly three features: . | The type checker Apalache comes with a type checker for TLA+ which helps you to develop models without creating bugs in the model itself | Trace invariants Apalache lets you define boolean functions over the entire sequence of states in an execution. This lets you detect system behavior that single state boolean functions would not be able to detect | Enumerating counterexamples Apalache can generate multiple traces for a given behavior. This enables generating thorough tests for a real system. | . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/apalache_vs_tlc.html#feature-asymmetry",
    "relUrl": "/docs/tla_basics_tutorials/apalache_vs_tlc.html#feature-asymmetry"
  },"4": {
    "doc": "(Bonus) Ecosystem",
    "title": "The TLA+ ecosystem",
    "content": "There are a number of resources in the ecosystem. The most important are . | The language itself | Apalache - a symbolic bounded model checker | TLC - an explicit state model checker | . The Apalache and TLC model checkers each have pros and cons that make them suited for evaluating different models. There are common names you will see repeatedly as you learn TLA+. We use the following . | VSCode Plugin - highlights and shows syntax errors, runs TLC We recommend using this. | TLA+ standard modules - the standard library These modules are automatically found by Apalache and TLC when you include them. | Google Group - the official discussion forum for TLA+ It’s worth searching here if you’re stuck. | tlaplus repository issues - the issues for the TLA+ components maintained by Microsoft It’s worth searching here if you’re stuck. | . Additional keywords you might see, but that we don’t use in the basic tutorials: . | Modelator - a tool for model-based testing using TLA+ models modelator can generate hundreds of tests from a model and run them against your real system. | SANY - the canonical TLA+ parser used by TLC and Apalache You don’t need to worry about using SANY on its own. | Toolbox - a bespoke IDE for writing TLA+ and running TLC. The toolbox has unique features useful in niche circumstances. We recommend trying the toolbox only after getting used to TLA+, if you need to. | TLA+ community modules - additional modules contributed by the community Using them may require downloading and providing the path for the package. | Pluscal - another language which translates to TLA+ Pluscal is less expressive than TLA+ and uses a different syntax. There are Pascal and C-like flavours. You have to translate it to TLA+ using a transpiler before checking a model written in it. We recommend trying it only after getting used to using regular TLA+. | Specifying Systems - a book on TLA+ written by Leslie Lamport, original creator of TLA+ It contains useful information on niche features of TLC and TLA+. | . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ecosystem.html#the-tla-ecosystem",
    "relUrl": "/docs/tla_basics_tutorials/ecosystem.html#the-tla-ecosystem"
  },"5": {
    "doc": "(Bonus) Ecosystem",
    "title": "Footnote",
    "content": "Please note there are many more tools and works in the ecosystem. This page contains a basic subset. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ecosystem.html#footnote",
    "relUrl": "/docs/tla_basics_tutorials/ecosystem.html#footnote"
  },"6": {
    "doc": "(Bonus) Ecosystem",
    "title": "(Bonus) Ecosystem",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ecosystem.html",
    "relUrl": "/docs/tla_basics_tutorials/ecosystem.html"
  },"7": {
    "doc": "Ethereum Exploit",
    "title": "Finding an Ethereum exploit using Apalache",
    "content": "The .tla and other referenced files are included here. In ‘Hello World’ we used TLC to check a simple model. Now we will walk through a real model. The model models part of the ERC20 Ethereum blockchain technical standard; in particular the model can be used to generate a trace which exploits the API to transfer funds to an attackers address. The model was written by Igor Konnov. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#finding-an-ethereum-exploit-using-apalache",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#finding-an-ethereum-exploit-using-apalache"
  },"8": {
    "doc": "Ethereum Exploit",
    "title": "Intro",
    "content": "This model builds on the skills gained in ‘Hello World’ and ‘Typechecking’. The model variables use a richer set of data structures including integers, tuples, and key value maps (called functions in TLA+). The operator definitions are also more complicated, making more use of the LET statement to define helper operators inline. Finally, we will search for a more interesting behavior pattern than we did in ‘Hello World’: an execution that withdraws funds from a target wallet into an attackers wallet. We will see how TLA+ can be used to find vulnerabilities in a real system. You will probably find the cheatsheet useful while reading. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#intro",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#intro"
  },"9": {
    "doc": "Ethereum Exploit",
    "title": "The system we model",
    "content": "The system being modeled maintains addresses for blockchain wallets. It’s possible to transfer funds between addresses by executing transactions on the blockchain. There is a pool which holds transactions that have been submitted for execution, but have not yet been executed; these are pending transactions. Additionally, it is possible for wallet owners to delegate the ability to transfer their funds to a third party. This functionality is used in smart contracts. The Ethereum ERC20 standard defines an API for the system. The API has three calls . | SubmitTransfer(sender, toAddr, value) Submit a transfer order, sending value from the address of sender to toAddr. The order will only be processed if the balance of the sender address is at least value. | SubmitTransferFrom(sender, fromAddr, toAddr, value) Submit a transfer order, sending value from fromAddr to toAddr. The order will only be processed if the balance of the fromAddr is at least value and the owner of fromAddr has previously given permission for sender to send transactions on their behalf, via the SubmitApprove(…) call. | SubmitApprove(sender, spender, value) Submit an order allowing spender to transfer funds from sender’s address on their behalf, up to a total sum of value. | . The orders are submitted to the pendingTransactions pool. While the pool is not empty the blockchain will select and execute orders from the pool in a non-deterministic order. You may notice that the descriptions of the Submit* API calls are not totally clear with respect to ordering and timing. We will see that this is exactly the problem with the API. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#the-system-we-model",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#the-system-we-model"
  },"10": {
    "doc": "Ethereum Exploit",
    "title": "Defining State",
    "content": "We isolate parts of the blockchain system relevant to the behavior we are trying to understand. For the purpose of verifying the API we should track . | A set of blockchain addresses | The balance of each address | For each pair of addresses (A, B), the value address A has allowed address B to transfer to third parties on their behalf | The pool of pending transactions | . Data Declarations . Apalache lets you define type aliases in a typedefs.tla file. You import them all at once using the EXTEND keyword in other .tla files. We define aliases for an ADDR (address) and TX (transaction) type. \\* (In typedefs.tla) (* An account address, in our case, simply an uninterpreted string: @typeAlias: ADDR = Str; A transaction (a la discriminated union but all fields are packed together): @typeAlias: TX = [ tag: Str, id: Int, fail: Bool, sender: ADDR, spender: ADDR, fromAddr: ADDR, toAddr: ADDR, value: Int ]; *) . We define ADDR as an alias for the builtin Str string type. We define TX as a composition of built in types and other aliases. In this case TX is a record (struct) with types associated to keys. For the state we define variables . VARIABLES \\* \\* Token balance for every account. This is exactly as `balanceOf` in ERC20. \\* @type: ADDR -&gt; Int; balanceOf, \\* \\* Allowance to transfer tokens \\* from owner (1st element) by spender (2nd element). \\* This is exactly as `allowance` of ERC20. \\* @type: &lt;&lt;ADDR, ADDR&gt;&gt; -&gt; Int; allowance, \\* \\* Pending transactions to be executed against the contract. \\* Note that we have a set of transactions instead of a sequence, \\* as the order of transactions on Ethereum is not predefined. \\* To make it possible to submit two 'equal' transactions, \\* we introduce a unique transaction id. \\* @type: Set(TX); pendingTransactions, \\* \\* The last executed transaction. \\* @type: TX; lastTx, \\* \\* A serial number to assign unique ids to transactions \\* @type: Int; nextTxId . Breaking them down we have . | balanceOf with type ADDR -&gt; Int This is Apalache’s notation for specifying function (key value map) types. balanceOf is a function mapping addresses (ADDR) to integers (Int). | allowance with type &lt;&lt;ADDR, ADDR&gt;&gt; -&gt; Int Each allowance is an association between an allowing address, the allowed address, and the value that the allowing address allows the allowed address to transfer. We can store this as a function mapping pairs («T,T») to integers. | pendingTransactions with type Set(TX) The pendingTransactions pool is a set, as it has no concept of order. In this case it is a set of the TX type that we defined an alias for earlier. | lastTx with type TX The model checker will always give you traces as a sequence of states. It can be useful to have additional information to understand why one state follows another in the sequence. Storing additional state variables can be useful if they record the reason that the state changed the way it did. Saving the last processed transaction in the lastTx variable will make it easier for us to infer the flow of transactions in a trace. | nextTxId with type Int We would like to have multiple identical transactions in the pendingTransactions pool. We modeled the pool as a set, which can only store one of a given value. Adding a unique id to transactions lets us store multiple logically identical transactions in the pool. | . The absolute values of the addresses in the system are unimportant and we can model a fixed number of addresses without it affecting API interactions. This means we can define an immutable set of ADDR types: an operator taking no input and giving us a fixed set of addresses. \\* @type: () =&gt; Set(ADDR); ADDRESSES == { \"addr1\", \"addr2\", \"addr3\" } . Data Definitions . We have declared the data in the system but not defined concrete values. In particular we should define initial values for the variables. Init == \\* every address has a non-negative number of tokens /\\ balanceOf \\in [ADDRESSES -&gt; Nat] \\* no account is allowed to withdraw from another account /\\ allowance = [ pair \\in ADDRESSES \\X ADDRESSES |-&gt; 0 ] \\* no pending transactions /\\ pendingTransactions = {} /\\ nextTxId = 0 /\\ lastTx = [ id |-&gt; 0, tag |-&gt; \"None\", fail |-&gt; FALSE ] . TLA+ syntax can be opaque. Step by step . | balanceOf \\in [ADDRESSES -&gt; Nat] balanceOf is in the set of all functions mapping addresses to natural numbers | allowance = [ pair \\in ADDRESSES \\X ADDRESSES |-&gt; 0 ] allowance is the function whose keys are all the possible pairs of addresses, and whose values are all 0. | pendingTransactions = {} pendingTransactions is the empty set | nextTxId = 0 nextTxId is 0 | lastTx = [ id |-&gt; 0, tag |-&gt; \"None\", fail |-&gt; FALSE ] lastTx is the record mapping id to 0, tag to “None” and fail to FALSE | . Remember: Init is a boolean function that will evaluate true for a subset of all possible states. In this case Init will match (hold true for) states where . | balanceOf is a function mapping addresses to natural numbers | AND allowance is the function mapping all pairs of addresses to 0 | AND pendingTransactions is the empty set | AND nextTxId is 0 | | AND lastTx is _exactly_ the record [ id | -&gt; 0, tag | -&gt; \"None\", fail | -&gt; FALSE ] | . | . The model checker will check all systems whose initial state matches the above criteria! . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#defining-state",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#defining-state"
  },"11": {
    "doc": "Ethereum Exploit",
    "title": "Defining Transitions",
    "content": "We have defined the variables in the system, now we must define transitions. The Next operator defines which transitions are allowed in the system. Next == \\/ \\E sender, toAddr \\in ADDRESSES, value \\in Int: SubmitTransfer(sender, toAddr, value) \\/ \\E sender, fromAddr, toAddr \\in ADDRESSES, value \\in Int: SubmitTransferFrom(sender, fromAddr, toAddr, value) \\/ \\E sender, spender \\in ADDRESSES, value \\in Int: SubmitApprove(sender, spender, value) \\/ \\E tx \\in pendingTransactions: \\/ /\\ tx.tag = \"transfer\" /\\ ProcessTransfer(tx) \\/ /\\ tx.tag = \"transferFrom\" /\\ ProcessTransferFrom(tx) \\/ /\\ tx.tag = \"approve\" /\\ ProcessApprove(tx) . There are 6 actions, or types of transition in the system. They are . | SubmitTransfer(sender, toAddr, value) | SubmitTransferFrom(sender, fromAddr, toAddr, value) | SubmitApprove(sender, spender, value) | ProcessTransfer(tx) | ProcessTransferFrom(tx) | ProcessApprove(tx) | . The three Submit* actions match the API calls and the Process* actions define the processing of a pending transaction from the pendingTransactions pool. The actions are written using parameterized operators, this makes the code more readable. SubmitTx(tx) == /\\ pendingTransactions' = pendingTransactions \\union { tx } /\\ lastTx' = [ id |-&gt; 0, tag |-&gt; \"None\", fail |-&gt; FALSE ] /\\ nextTxId' = nextTxId + 1 /\\ UNCHANGED &lt;&lt;balanceOf, allowance&gt;&gt; SubmitTransfer(_sender, _toAddr, _value) == SubmitTx([ id |-&gt; nextTxId, tag |-&gt; \"transfer\", fail |-&gt; FALSE, sender |-&gt; _sender, toAddr |-&gt; _toAddr, value |-&gt; _value ]) SubmitTransferFrom(_sender, _fromAddr, _toAddr, _value) == SubmitTx([ id |-&gt; nextTxId, tag |-&gt; \"transferFrom\", fail |-&gt; FALSE, sender |-&gt; _sender, fromAddr |-&gt; _fromAddr, toAddr |-&gt; _toAddr, value |-&gt; _value ]) SubmitApprove(_sender, _spender, _value) == SubmitTx([ id |-&gt; nextTxId, tag |-&gt; \"approve\", fail |-&gt; FALSE, sender |-&gt; _sender, spender |-&gt; _spender, value |-&gt; _value ]) . We see that each of the Submit* operators delegates to the SubmitTx(tx) operator. Each operator adds a new transaction of TX type to the pendingTransactions set (and increments the unique nextTxId). Each transaction is tagged with a string “transfer”, “transferFrom” or “approve”. This allows us to disambiguate transactions in the Process* actions. ProcessTransfer . The Process* actions make use of the LET keyword to define inline operators. Inline operators are analogous to local variables or lambda functions in typical programming languages. ProcessTransfer(tx) == /\\ pendingTransactions' = pendingTransactions \\ { tx } /\\ UNCHANGED &lt;&lt;allowance, nextTxId&gt;&gt; /\\ LET fail == \\/ tx.value &lt; 0 \\/ tx.value &gt; balanceOf[tx.sender] \\/ tx.sender = tx.toAddr IN /\\ lastTx' = [ tx EXCEPT !.fail = fail ] /\\ IF fail THEN UNCHANGED balanceOf ELSE \\* transaction succeeds \\* update the balances of the 'sender' and 'toAddr' addresses balanceOf' = [ balanceOf EXCEPT ![tx.sender] = @ - tx.value, ![tx.toAddr] = @ + tx.value ] . ProcessTransfer takes a TX type tx, tagged with “transfer”, as input. For a pair of states (CurrentState, NextState). In all cases where the ProcessTransfer action is taken, the tx is removed from pendingTransactions, and allowance and nextTxId do not change. Additionally, there may be a change to the balanceOf variable. fail is defined as a boolean: the transaction will fail if the value field is negative, or if the value is greater than the senders balance, or if the sender tries to send funds to themself (tx.sender = tx.toAddr). fail is used: the lastTx variable in NextState (lastTx’) must be equal to tx, except for in the .fail key - where it should match the value of the inline operator fail. The syntax [ f EXCEPT !.foo = bar ] is the record f except for that the key foo is equal to bar. fail is also used to update the balanceOf variable (or not). If fail is true then the transaction is void and the balances are not updated. However, if the transaction did not fail then the balanceOf variable is updated for the keys tx.sender and tx.toAddr. The syntax [f EXCEPT ![foo] = g(@)] is the function f except for that the key equal to the value of foo is equal to the value of the operator g(@), where @ is the value of of foo in f (@ can be used as a variable). If the transaction does not fail, funds are transferred: the sender balance decreases by tx.value and the toAddr balance increases by tx.value. ProcessTransferFrom . transfer transactions are made by addresses transferring their own funds. transferFrom transactions transfer funds between any two addresses, so long as the caller of transferFrom has been given approval. ProcessTransferFrom(tx) == /\\ pendingTransactions' = pendingTransactions \\ { tx } /\\ UNCHANGED nextTxId /\\ LET fail == \\/ tx.value &lt; 0 \\/ tx.value &gt; balanceOf[tx.fromAddr] \\/ tx.value &gt; allowance[tx.fromAddr, tx.sender] \\/ tx.fromAddr = tx.toAddr IN /\\ lastTx' = [ tx EXCEPT !.fail = fail ] /\\ IF fail THEN UNCHANGED &lt;&lt;balanceOf, allowance&gt;&gt; ELSE \\* transaction succeeds \\* update the balances of the 'fromAddr' and 'toAddr' addresses /\\ balanceOf' = [ balanceOf EXCEPT ![tx.fromAddr] = @ - tx.value, ![tx.toAddr] = @ + tx.value ] \\* decrease the allowance for the sender /\\ allowance' = [ allowance EXCEPT ![tx.fromAddr, tx.sender] = @ - tx.value ] . Similarly to the ProcessTransfer action, ProcessTransferFrom defines an inline fail operator and uses it control the logic elsewhere in the action. In this case the transaction will fail if . | the value is negative | the fromAddr has insufficient balance to make the transfer | the value is greater than the amount tx.fromAddr has allowed tx.sender to spend on their behalf | the fromAddr and toAddr are the same | . If the transaction does not fail, then the balances are updated and the spending allowance is decreased. ProcessApprove . ProcessApprove does not transfer funds: it updates the allowance (quantity of funds) that tx.spender can spend on behalf of tx.sender. The transaction will fail if the tx.value field is negative or if tx.sender = tx.spender. ProcessApprove(tx) == /\\ pendingTransactions' = pendingTransactions \\ { tx } /\\ UNCHANGED &lt;&lt;balanceOf, nextTxId&gt;&gt; /\\ LET fail == tx.value &lt; 0 \\/ tx.sender = tx.spender IN /\\ lastTx' = [ tx EXCEPT !.fail = fail ] /\\ IF fail THEN UNCHANGED allowance ELSE \\* transaction succeeds \\* set the allowance for the pair &lt;&lt;sender, spender&gt;&gt; to value allowance' = [ allowance EXCEPT ![tx.sender, tx.spender] = tx.value ] . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#defining-transitions",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#defining-transitions"
  },"12": {
    "doc": "Ethereum Exploit",
    "title": "Type checking",
    "content": "We should run the type checker to make sure we have not made a silly mistake writing the model. The model has medium complexity and size so annotating types for the variables and the ADDRESSES operator should be enough for Apalache to be able to understand the entire model. java -jar apalache-pkg-0.17.5-full.jar typecheck ERC20.tla # Apalache output: # ... # Type checker [OK] . You should see Type checker [OK]. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#type-checking",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#type-checking"
  },"13": {
    "doc": "Ethereum Exploit",
    "title": "Finding an exploit",
    "content": "Trace Invariants using Seq(STATE) . We have defined the state and the allowed transitions. It is time to explore behavior using Apalache. Apalache lets you define trace invariants: boolean functions over the entire sequence of states in an execution. They let you detect system behavior that single state boolean functions would not be able to detect. A trace invariant should be an operator of the following form . \\* @type: Seq(STATE) =&gt; Bool; Foo(trace) == ... In order to use trace invariants we must define a STATE type alias in typdefs.tla. The STATE type should be a record using variable names as keys, mapping to the variable type. (* @typeAlias: STATE = [ balanceOf: ADDR -&gt; Int, allowance: &lt;&lt;ADDR, ADDR&gt;&gt; -&gt; Int, pendingTransactions: Set(TX), lastTx: TX, nextTxId: Int ]; *) . It is straightforward to copy the declerations following the VARIABLES keyword that we already wrote. Given the alias, Foo allows us to access any state in the execution trace using sequence indexing (1-based). For example we can access the initial state with trace[1], the second state with trace[2] etc. Trace Invariant: All Fund Transfers Have Sufficient Approval . The Ethereum API has the expected behavior that if you approve a third party to make transfers from your address, then the sum of those transfers should not exceed the value that you specified. We write a trace invariant that says . “Whenever a third party makes transfers from a given address on behalf of the owner, an Approve transaction with a value not less than the sum of the transfers should have been submitted by the owner of the address, before all transfers included in the sum were made.” . We can specify this criteria in TLA+ . \\* @type: Seq(STATE) =&gt; Bool; AllFundTransfersHaveSufficientApproval(trace) == \\A spender, fromAddr \\in ADDRESSES: LET TransferIndices == { i \\in DOMAIN trace: LET tx == trace[i].lastTx IN /\\ tx.tag = \"transferFrom\" /\\ ~tx.fail /\\ tx.fromAddr = fromAddr /\\ tx.sender = spender /\\ 0 &lt; tx.value } IN \\* the sum of all transfers from 'fromAddr' to 'toAddr' LET SumOfTransfers == LET Add(sum, i) == sum + trace[i].lastTx.value IN FoldSet(Add, 0, TransferIndices) IN \\* there exists an approval for the whole transfer sum LET ExistsApprovalForSumInPast == \\E i \\in DOMAIN trace: LET approval_tx == trace[i].lastTx IN /\\ approval_tx.tag = \"approve\" /\\ spender = approval_tx.spender /\\ fromAddr = approval_tx.sender \\* all transfers are made after the approval /\\ \\A j \\in TransferIndices: i &lt; j /\\ ~approval_tx.fail \\* the sender of this transaction is allowing the spender \\* to spend at most the sum of the made transfers. /\\ SumOfTransfers &lt;= approval_tx.value IN SumOfTransfers &lt;= 0 \\/ ExistsApprovalForSumInPast . There are a few things going on here. First of all we must check the condition for all pairs of addresses . \\A spender, fromAddr \\in ADDRESSES: ... For each pair we define an inline operator TransferIndices, the set of indexes into the sequence of states in which a transfer was made by spender from fromAddr to another address. LET TransferIndices == { i \\in DOMAIN trace: LET tx == trace[i].lastTx IN /\\ tx.tag = \"transferFrom\" /\\ ~tx.fail /\\ tx.fromAddr = fromAddr /\\ tx.sender = spender /\\ 0 &lt; tx.value } . We can collect the sum of these transfers by using the FoldSet operator included in the Apalache library module (EXTENDS Apalache). LET SumOfTransfers == LET Add(sum, i) == sum + trace[i].lastTx.value IN FoldSet(Add, 0, TransferIndices) . The FoldSet operator is one of the most useful reusable operators available. The form is . FoldSet(Combiner, initialValue, inputSet) . where Combiner is an operator . Combiner(accumulatedValue, nextValue) . The value of a FoldSet call is the result of repeatedly applying Combiner to successive elements in inputSet (in unpredictable order) as well as the value accumulated so far in the process. Our usage SumOfTransfers sums the .value field of the lastTx variable for each state indexed by TransferIndices. LET SumOfTransfers == LET Add(sum, i) == sum + trace[i].lastTx.value IN FoldSet(Add, 0, TransferIndices) . A last component of our trace operator is ExistsApprovalForSumInPast . LET ExistsApprovalForSumInPast == \\E i \\in DOMAIN trace: LET approval_tx == trace[i].lastTx IN /\\ approval_tx.tag = \"approve\" /\\ spender = approval_tx.spender /\\ fromAddr = approval_tx.sender \\* all transfers are made after the approval /\\ \\A j \\in TransferIndices: i &lt; j /\\ ~approval_tx.fail \\* the sender of this transaction is allowing the spender \\* to spend at most the sum of the made transfers. /\\ SumOfTransfers &lt;= approval_tx.value . The operator will evaluate true if there exists an approval in the transaction history that precedes each transfer, and the approval value was not less than the sum of total transfers. Finally, we can put the pieces together. AllFundTransfersHaveSufficientApproval(trace) == \\A spender, fromAddr \\in ADDRESSES: \\* ... IN SumOfTransfers &lt;= 0 \\/ ExistsApprovalForSumInPast . The final value of AllFundTransfersHaveSufficientApproval will be false if and only if there is a pair of addresses with a positive SumOfTransfers and no approval for those transfers was made. Check the invariant . java -jar apalache-pkg-0.17.5-full.jar check --inv=AllFundTransfersHaveSufficientApproval ERC20.tla # Apalache output: # ... # State 8: Checking 1 trace invariant(s) # State 8: trace invariant 0 violated. Check the counterexample in: ... # Found 1 error(s) . An error! . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#finding-an-exploit",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#finding-an-exploit"
  },"14": {
    "doc": "Ethereum Exploit",
    "title": "Interpreting an Apalache counterexample",
    "content": "We should check the counterexample1.tla file (located in the _apalache-out) directory. It should contain a sequence of states similar to the following (but may not be identical) . (* Initial state *) State0 == allowance = (((((((&lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 28 @@ \"addr2\" :&gt; 14) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 0, tag |-&gt; \"None\"] /\\ nextTxId = 0 /\\ pendingTransactions = {} (* Transition 2 to State1 *) State1 == allowance = (((((((&lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 28 @@ \"addr2\" :&gt; 14) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 0, tag |-&gt; \"None\"] /\\ nextTxId = 1 /\\ pendingTransactions = {[fail |-&gt; FALSE, id |-&gt; 0, sender |-&gt; \"addr1\", spender |-&gt; \"addr3\", tag |-&gt; \"approve\", value |-&gt; 16]} (* Transition 1 to State2 *) State2 == allowance = (((((((&lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 28 @@ \"addr2\" :&gt; 14) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 0, tag |-&gt; \"None\"] /\\ nextTxId = 2 /\\ pendingTransactions = { [fail |-&gt; FALSE, fromAddr |-&gt; \"addr1\", id |-&gt; 1, sender |-&gt; \"addr3\", tag |-&gt; \"transferFrom\", toAddr |-&gt; \"addr2\", value |-&gt; 6], [fail |-&gt; FALSE, id |-&gt; 0, sender |-&gt; \"addr1\", spender |-&gt; \"addr3\", tag |-&gt; \"approve\", value |-&gt; 16] } (* Transition 3 to State3 *) State3 == allowance = (((((((&lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 16) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 28 @@ \"addr2\" :&gt; 14) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 0, sender |-&gt; \"addr1\", spender |-&gt; \"addr3\", tag |-&gt; \"approve\", value |-&gt; 16] /\\ nextTxId = 2 /\\ pendingTransactions = {[fail |-&gt; FALSE, fromAddr |-&gt; \"addr1\", id |-&gt; 1, sender |-&gt; \"addr3\", tag |-&gt; \"transferFrom\", toAddr |-&gt; \"addr2\", value |-&gt; 6]} (* Transition 6 to State4 *) State4 == allowance = (((((((&lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 10) @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 22 @@ \"addr2\" :&gt; 20) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, fromAddr |-&gt; \"addr1\", id |-&gt; 1, sender |-&gt; \"addr3\", tag |-&gt; \"transferFrom\", toAddr |-&gt; \"addr2\", value |-&gt; 6] /\\ nextTxId = 2 /\\ pendingTransactions = {} (* Transition 2 to State5 *) State5 == allowance = (((((((&lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 10) @@ &lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 22 @@ \"addr2\" :&gt; 20) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 0, tag |-&gt; \"None\"] /\\ nextTxId = 3 /\\ pendingTransactions = {[fail |-&gt; FALSE, id |-&gt; 2, sender |-&gt; \"addr1\", spender |-&gt; \"addr3\", tag |-&gt; \"approve\", value |-&gt; 24]} (* Transition 1 to State6 *) State6 == allowance = (((((((&lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 10) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 22 @@ \"addr2\" :&gt; 20) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 0, tag |-&gt; \"None\"] /\\ nextTxId = 4 /\\ pendingTransactions = { [fail |-&gt; FALSE, fromAddr |-&gt; \"addr1\", id |-&gt; 3, sender |-&gt; \"addr3\", tag |-&gt; \"transferFrom\", toAddr |-&gt; \"addr2\", value |-&gt; 20], [fail |-&gt; FALSE, id |-&gt; 2, sender |-&gt; \"addr1\", spender |-&gt; \"addr3\", tag |-&gt; \"approve\", value |-&gt; 24] } (* Transition 3 to State7 *) State7 == allowance = (((((((&lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 24) @@ &lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 22 @@ \"addr2\" :&gt; 20) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, id |-&gt; 2, sender |-&gt; \"addr1\", spender |-&gt; \"addr3\", tag |-&gt; \"approve\", value |-&gt; 24] /\\ nextTxId = 4 /\\ pendingTransactions = {[fail |-&gt; FALSE, fromAddr |-&gt; \"addr1\", id |-&gt; 3, sender |-&gt; \"addr3\", tag |-&gt; \"transferFrom\", toAddr |-&gt; \"addr2\", value |-&gt; 20]} (* Transition 6 to State8 *) State8 == allowance = (((((((&lt;&lt;\"addr2\", \"addr1\"&gt;&gt; :&gt; 0 @@ &lt;&lt;\"addr3\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr3\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr3\"&gt;&gt; :&gt; 4) @@ &lt;&lt;\"addr1\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr2\", \"addr2\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr3\", \"addr1\"&gt;&gt; :&gt; 0) @@ &lt;&lt;\"addr1\", \"addr1\"&gt;&gt; :&gt; 0 /\\ balanceOf = (\"addr1\" :&gt; 2 @@ \"addr2\" :&gt; 40) @@ \"addr3\" :&gt; 20 /\\ lastTx = [fail |-&gt; FALSE, fromAddr |-&gt; \"addr1\", id |-&gt; 3, sender |-&gt; \"addr3\", tag |-&gt; \"transferFrom\", toAddr |-&gt; \"addr2\", value |-&gt; 20] /\\ nextTxId = 4 /\\ pendingTransactions = {} . For brevity here is a cleaned up summary: . # State 0 (Init) balances = [28, 14, 20] # State 1 - an approval is submitted. balances = [28, 14, 20] pending = { addr1 approve addr3 for value 16 } # State 2 - a transferFrom is submitted. balances = [28, 14, 20] pending = { addr1 approve addr3 with value 16 addr3 transfer 6 from addr1 to addr2 } # State 3 - the approval is processed. allowances = { addr1 approve addr3 with value 16 } balances = [28, 14, 20] pending = { addr3 transfer 6 from addr1 to addr2 } # State 4 - the transferFrom is processed. allowances = { addr1 approve addr3 with value 10 } balances = [22, 20, 20] # State 5 - an approval is submitted. allowances = { addr1 approve addr3 with value 10 } balances = [22, 20, 20] pending = { addr1 approve addr3 with value 24 } # State 6 - a transferFrom is submitted. allowances = { addr1 approve addr3 with value 10 } balances = [22, 20, 20] pending = { addr1 approve addr3 with value 24 addr3 transfer 20 from addr1 to addr2 } # State 7 - the approval is processed. allowances = { addr1 approve addr3 with value 24 } balances = [22, 20, 20] pending = { addr3 transfer 20 from addr1 to addr2 } # State 8 - the transferFrom is processed. allowances = { addr1 approve addr3 with value 4 } balances = [2, 40, 20] . The problem is that addr1 made two approvals for addr3 to transfer its funds . | approved transferring up to 16 | approved transferring up to 24 | . But addr3 made two transferFroms from addr1 to addr2 . | transfer 6 | transfer 20 | . Both transfers succeeded with a sum of 26, however, the intention of addr1 was to approve a lifetime maximum transfer of 16, and then increase it to 24. The problem is that the first transfer happened in between the first and second approvals. The second approval overwrote the original value, not taking into account the transfer made in the meantime. This enabled a second transfer to withdraw too much. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#interpreting-an-apalache-counterexample",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#interpreting-an-apalache-counterexample"
  },"15": {
    "doc": "Ethereum Exploit",
    "title": "Wrapping up",
    "content": "This tutorial . | Described the problem being modeled | How to declare appropriate state variables using advanced data types | How to define appropriate initial states in Init | How to define appropriate transitions using actions in Next | Type checked the model | Writing a trace invariant - including using FoldSet | Analysed a counterexample.tla file that Apalache generated, showing a flaw in the API | . Try the next one :) . Further resources . | Description of attack scenario. Written by Mikhail Vladimirov and Dmitry Khovratovich. | Relevant Ethereum API | Apalache library module | Apalache trace invariants | . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html#wrapping-up",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html#wrapping-up"
  },"16": {
    "doc": "Ethereum Exploit",
    "title": "Ethereum Exploit",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/ethereum.html",
    "relUrl": "/docs/tla_basics_tutorials/ethereum.html"
  },"17": {
    "doc": "Generating Traces",
    "title": "Generating traces for automated testing using Apalache",
    "content": "The .tla and other referenced files are included here. Apalache allows you to generate more than one trace that satisfies a given behavior specified by a state invariant or trace invariant. Generating multiple traces can be useful because different traces may give you insight into your system. There may be several different methods of exploiting the same vulnerability, for example. Generating multiple traces is also useful for model-based testing, where the goal is to use a model to generate tests for a software implementation of the system. This tutorial shows you . | How to use Apalache to generate multiple traces | How to control the way that traces differ using Apalache’s VIEW feature | . The tutorial builds on the skills gained in ‘Hello World’ and ‘Ethereum’ where we model checked state and trace invariants but only generated a single trace. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/generating_traces.html#generating-traces-for-automated-testing-using-apalache",
    "relUrl": "/docs/tla_basics_tutorials/generating_traces.html#generating-traces-for-automated-testing-using-apalache"
  },"18": {
    "doc": "Generating Traces",
    "title": "Demonstrating multiple traces",
    "content": "For instruction purposes we will use a small and simple model. ---- MODULE multiple_traces ---- EXTENDS Integers, Sequences, Apalache, typedefs VARIABLES \\* @type: Str; auxiliary_str, \\* @type: Int; important_int Init == /\\ auxiliary_str = \"foo\" /\\ important_int = 0 ChangeAuxiliaryStr == /\\ auxiliary_str' \\in {\"foo\", \"bar\", \"wiz\"} /\\ UNCHANGED important_int AddToImportantInt == /\\ UNCHANGED auxiliary_str /\\ \\E x \\in 1..4 : important_int' = important_int + x Next == \\/ ChangeAuxiliaryStr \\/ AddToImportantInt \\* @type: () =&gt; Bool; ImportantIntIs6 == LET Behavior == important_int = 6 IN ~Behavior \\* @type: Seq(STATE) =&gt; Bool; ImportantIntIsOddUntil6(trace) == LET Behavior == /\\ trace[Len(trace)].important_int = 6 /\\ \\A i \\in DOMAIN trace : \\/ (i = 1 \\/ i = Len(trace)) \\/ trace[i].important_int % 2 = 1 IN ~Behavior View == important_int ==== . Remember that to use trace invariants we must define a STATE type alias in typdefs.tla . ---- MODULE typedefs ---- (* @typeAlias: STATE = [ auxiliary_str : Str, important_int : Int ]; *) include_typedefs == TRUE ==== . Defining a View operator . The model contains two state variables. Suppose that auxiliary_str represents some data in your system that’s needed for bookkeeping, but won’t have an effect on the interesting behaviors. Suppose also that important_int contains some highly critical data. The goal is to generate traces which differ only by the value of important_int in each state. Apalache’s VIEW feature lets you define an operator named View taking all state variables and outputting some value. Apalache ensures that all pairs of generated traces t1 and t2 differ on the value of that function for at least one state. By writing . View == important_int . we ensure that all the traces generated will have a different sequence of values for important_int. Our Invariants . The model contains operators defining the inverses of two behaviors we would like to generate traces for. The state invariant ImportantIntIs6 will evaluate to false in any state where important_int is 6. \\* @type: () =&gt; Bool; ImportantIntIs6 == LET Behavior == important_int = 6 IN ~Behavior . If we use Apalache to check ImportantIntIs6 it will find a single trace where the operator evaluates to false: meaning that the integer is 6. apalache check --inv=ImportantIntIs6 multiple_traces.tla # Apalache output: # ... # State 2: Checking 1 trace invariant(s) # State 2: trace invariant 0 violated. Check the counterexample in: counterexample1.json # Found 1 error(s) # The outcome is: Error . \\* counterexample1.json (* Initial state *) State0 == auxiliary_str = \"foo\" /\\ important_int = 0 (* Transition 1 to State1 *) State1 == auxiliary_str = \"foo\" /\\ important_int = 3 (* Transition 1 to State2 *) State2 == auxiliary_str = \"foo\" /\\ important_int = 6 . This is useful but we can generate more traces by running . apalache check --inv=ImportantIntIs6 --max-error=3 --view=View multiple_traces.tla # Apalache output: # ... # State 2: Checking 1 state invariants # State 2: state invariant 0 violated. Check the counterexample in: counterexample1.json # State 2: state invariant 0 violated. Check the counterexample in: counterexample2.json # State 2: state invariant 0 violated. Check the counterexample in: counterexample3.json # Found 3 error(s) # The outcome is: Error . You should see three traces similar to the below . \\* counterexample1.json (* Initial state *) State0 == auxiliary_str = \"foo\" /\\ important_int = 0 (* Transition 1 to State1 *) State1 == auxiliary_str = \"foo\" /\\ important_int = 2 (* Transition 1 to State2 *) State2 == auxiliary_str = \"foo\" /\\ important_int = 6 \\* counterexample2.json (* Initial state *) State0 == auxiliary_str = \"foo\" /\\ important_int = 0 (* Transition 1 to State1 *) State1 == auxiliary_str = \"foo\" /\\ important_int = 3 (* Transition 1 to State2 *) State2 == auxiliary_str = \"foo\" /\\ important_int = 6 \\* counterexample3.json (* Initial state *) State0 == auxiliary_str = \"foo\" /\\ important_int = 0 (* Transition 1 to State1 *) State1 == auxiliary_str = \"foo\" /\\ important_int = 4 (* Transition 1 to State2 *) State2 == auxiliary_str = \"foo\" /\\ important_int = 6 . Notice how they differ in the sequence of the important_int variable. We can also generate multiple traces for the trace operator ImportantIntIsOddUntil6 . \\* @type: Seq(STATE) =&gt; Bool; ImportantIntIsOddUntil6(trace) == LET Behavior == /\\ trace[Len(trace)].important_int = 6 /\\ \\A i \\in DOMAIN trace : \\/ (i = 1 \\/ i = Len(trace)) \\/ trace[i].important_int % 2 = 1 IN ~Behavior . If we check the operator as an invariant Apalache will generate traces whose behavior matches the inline Behavior operator. The behavior operator matches traces where important_int has a value 6 in the last state, and odd values for all states except the Init state and the last state. apalache check --inv=ImportantIntIsOddUntil6 --max-error=10 --view=View multiple_traces.tla # Apalache output: # ... State 2: Checking 1 trace invariant(s) State 2: trace invariant 0 violated. Check the counterexample in: ... Step 3: picking a transition out of 2 transition(s) State 3: Checking 1 trace invariant(s) State 3: trace invariant 0 violated. Check the counterexample in: ..... State 3: trace invariant 0 violated. Check the counterexample in: ... Step 4: picking a transition out of 2 transition(s) State 4: Checking 1 trace invariant(s) State 4: trace invariant 0 violated. Check the counterexample in: ..... State 4: trace invariant 0 violated. Check the counterexample in: ... Found 10 error(s) The outcome is: Error . Try inspecting the counterexample.tla files in the _apalache-out directory. Also try playing around with different invariants and particularly different View operators. For example, what do you think will happen if you specify . View == &lt;&lt;auxiliary_str, important_int&gt;&gt; . or . View == 3 &lt; important_int . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/generating_traces.html#demonstrating-multiple-traces",
    "relUrl": "/docs/tla_basics_tutorials/generating_traces.html#demonstrating-multiple-traces"
  },"19": {
    "doc": "Generating Traces",
    "title": "Wrapping up",
    "content": "This tutorial . | Why it’s useful to generate multiple traces | Differentiating traces with a View operator | Generating multiple traces for a state invariant | Generating multiple traces for a trace invariant | . That’s it. Congratulations for completing the basic tutorial set :) . Further resources . | model-based testing with modelator | Documentation: state invariants | Documentation: trace invariants | Documentation: VIEW | . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/generating_traces.html#wrapping-up",
    "relUrl": "/docs/tla_basics_tutorials/generating_traces.html#wrapping-up"
  },"20": {
    "doc": "Generating Traces",
    "title": "Generating Traces",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/generating_traces.html",
    "relUrl": "/docs/tla_basics_tutorials/generating_traces.html"
  },"21": {
    "doc": "Hello World",
    "title": "‘Hello world’ using TLC",
    "content": "The .tla and other referenced files are included here. Let’s model a system with two processes Alice and Bob. They are connected by a network that can lose and reorder messages. Alice will send two messages “hello” and “world” to Bob in an undetermined order. If Bob receives “hello” and then “world” he will become happy. hello_world.tla contains the model and hello_world.cfg contains the configuration file needed to model check it using TLC. Let’s unpack the body of the .tla file. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/hello_world.html#hello-world-using-tlc",
    "relUrl": "/docs/tla_basics_tutorials/hello_world.html#hello-world-using-tlc"
  },"22": {
    "doc": "Hello World",
    "title": "Boilerplate",
    "content": "You should write TLA in between two lines as below. This is an artifact of the module system. ---- MODULE hello_world ---- \\* content here... ==== . We extend (import) a modules from the standard library . EXTENDS Sequences \\* Import Sequences module from the standard library . it provides the Sequence data structure. It is a list. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/hello_world.html#boilerplate",
    "relUrl": "/docs/tla_basics_tutorials/hello_world.html#boilerplate"
  },"23": {
    "doc": "Hello World",
    "title": "The state machine",
    "content": "In TLA+ you define a state machine. There is an initial state, which is a choice of values for each variable declared. You also define the transitions allowed in the system. We model 4 pieces of state: Alice’s outbox, the messages in the network, Bob’s mood and Bob’s inbox. VARIABLES alices_outbox, network, bobs_mood, bobs_inbox . The Init operator defines the initial values of the state variables of the model. In TLA+ the term operator is used to mean something like a programming language function. Please take the Init operator on faith right now. Init == /\\ alices_outbox = {} \\* Alice has sent nothing (empty set) /\\ network = {} \\* AND so is the network /\\ bobs_mood = \"neutral\" \\* AND Bob's mood is neutral /\\ bobs_inbox = &lt;&lt;&gt;&gt; \\* AND Bob's inbox is an empty Sequence (list) . State machine transitions are pairs: (CurrentState, NextState). In TLA+ you describe the transitions allowed in the system by writing a boolean function over pairs (CurrentState, NextState). If a pair makes your boolean function evaluate true then the model checker will check that transition. In fact, the model checker will check all transitions that match your boolean function. This is what allows the model checker to exhaustively explore system behavior. Practically this means that you define transitions by writing actions: operators that take into account the CurrentState and the NextState. Because the variable names are the same in both states, you denote the NextState variables by appending the ‘ character to identifiers. In TLA+ you write actions OR’ed together in the Next operator. Next == \\/ AliceSend(\"hello\") \\/ AliceSend(\"world\") \\/ NetworkLoss \\/ NetworkDeliver \\/ BobCheckInbox . AliceSend(m) == /\\ m \\notin alices_outbox /\\ alices_outbox' = alices_outbox \\union {m} /\\ network' = network \\union {m} /\\ UNCHANGED &lt;&lt;bobs_mood, bobs_inbox&gt;&gt; NetworkLoss == /\\ \\E e \\in network: network' = network \\ {e} /\\ UNCHANGED &lt;&lt;bobs_mood, bobs_inbox, alices_outbox&gt;&gt; NetworkDeliver == /\\ \\E e \\in network: /\\ bobs_inbox' = bobs_inbox \\o &lt;&lt;e&gt;&gt; /\\ network' = network \\ {e} /\\ UNCHANGED &lt;&lt;bobs_mood, alices_outbox&gt;&gt; BobCheckInbox == /\\ bobs_mood' = IF bobs_inbox = &lt;&lt;\"hello\", \"world\"&gt;&gt; THEN \"happy\" ELSE \"neutral\" /\\ UNCHANGED &lt;&lt;network, bobs_inbox, alices_outbox&gt;&gt; . Pretend we are the model checker and we are currently ‘looking’ at the CurrentState C. We compute all possible NextState’s N, but we only consider a candidate N to be valid if Next is true when evaluated over the pair (C, N). Since Next is the OR’ing of actions, the pair will make Next true if it makes at least one of the actions true. Inspect the AliceSend(m) action for example. AliceSend(m) == /\\ m \\notin alices_outbox /\\ alices_outbox' = alices_outbox \\union {m} /\\ network' = network \\union {m} /\\ UNCHANGED &lt;&lt;bobs_mood, bobs_inbox&gt;&gt; . In English the action says this . “I am true when: my argument m is not in the set alices_outbox in the CurrentState AND alices_outbox in the NextState is the same as it is in the CurrentState, but with m included AND network in the NextState is the same as it is in the CurrentState, but with m included AND bobs_mood doesn’t change between the CurrentState and NextState AND bobs_inbox doesn’t change between the CurrentState and NextState “ . We must include the UNCHANGED keyword - there is no ambiguity in TLA+! . Consider NetworkLoss . NetworkLoss == /\\ \\E e \\in network: network' = network \\ {e} /\\ UNCHANGED &lt;&lt;bobs_mood, bobs_inbox, alices_outbox&gt;&gt; . This action is more advanced: it contains the ‘\\E’ (there exists) syntax. It says . “I am true when: There is an element e in the network of the CurrentState, and that element is not in the network of NextState AND bobs_mood doesn’t change between the CurrentState and NextState AND … “ . Let’s consider how a model checker could select a transition, given a current state where . alices_outbox = {\"hello\"} network = {\"hello\"} \\* ignore bobs variables for now . knowing that Next is . Next == \\/ AliceSend(\"hello\") \\/ AliceSend(\"world\") \\/ NetworkLoss \\* (ignore other operators for now) . In a pair (CurrentState, NextState) where AliceSend(“world”) was true NextState must look like . alices_outbox = {\"hello\", \"world\"} network = {\"hello\", \"world\"} \\* ignore bobs variables for now . and in one where NetworkLoss was true NextState would look like . alices_outbox = {\"hello\"} network = {} \\* ignore bobs variables for now . Next evaluates to true for both of these pairs, and the model checker will check both possibilities for us. Understanding Next as a boolean function over pairs of states is key. The Init operator is a special case, it’s a boolean function over one state only. (It’s not a special case if you consider it to be a boolean function over a pair (IgnoredState, InitialState) for a hidden IgnoredState). We have looked at AliceSend and NetworkLoss. Let’s look at NetworkDeliver and BobCheckInbox. NetworkDeliver == /\\ \\E e \\in network: /\\ bobs_inbox' = bobs_inbox \\o &lt;&lt;e&gt;&gt; /\\ network' = network \\ {e} /\\ UNCHANGED &lt;&lt;bobs_mood, alices_outbox&gt;&gt; . NetworkDeliver matches transitions where an element e is removed from the network set and added (with the \\o operator) to bobs_inbox list. BobCheckInbox == /\\ bobs_mood' = IF bobs_inbox = &lt;&lt;\"hello\", \"world\"&gt;&gt; THEN \"happy\" ELSE \"neutral\" /\\ UNCHANGED &lt;&lt;network, bobs_inbox, alices_outbox&gt;&gt; . As a challenge try to write BobCheckInbox (above) using only the logical operators /\\ and \\/. Answer: . BobCheckInbox == /\\ \\/ /\\ bobs_mood' = \"happy\" /\\ bobs_inbox = &lt;&lt;\"hello\", \"world\"&gt;&gt; \\/ /\\ bobs_mood' = \"neutral\" /\\ bobs_inbox /= &lt;&lt;\"hello\", \"world\"&gt;&gt; /\\ UNCHANGED &lt;&lt;network, bobs_inbox, alices_outbox&gt;&gt; . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/hello_world.html#the-state-machine",
    "relUrl": "/docs/tla_basics_tutorials/hello_world.html#the-state-machine"
  },"24": {
    "doc": "Hello World",
    "title": "Checking Invariants",
    "content": "We modeled the state machine so now we can check what properties it has. We can use a model checker to get sample execution traces beginning from the initial state and leading up to some state satisfying some boolean function. Precisely: we can find an sequence of states (T) starting in the initial state and ending in a state S that makes a boolean function P evaluate to true. In common terminology the sequence of states T is called a counterexample, and the boolean function is the negation of an Invariant. This means if we want to find an execution T whose final state satisfies P we write an invariant: Inv == ~P and we check that. (We check that Inv always holds: if it doesn’t then there exists a state where ~Inv = ~~P = P holds). If we want to make sure that no execution exists whose final state satisfies P we write an invariant: Inv == P and we hope that the model checker exhausts its search without finding a trace. Suppose we want to ensure that every (\\A means ‘for all’ in TLA+) message in the network was at some point sent by Alice. NothingUnexpectedInNetwork == \\A e \\in network: e \\in alices_outbox . NothingUnexpectedInNetwork is a boolean function over a single state. Using the model checker we can check it as an invariant. We use the following configuration for TLC (hello_world.cfg) . INIT Init NEXT Next INVARIANTS NothingUnexpectedInNetwork . We can check this using the VSCode plugin for TLA (through the context menu), or with . java -cp tla2tools.jar tlc2.TLC -config hello_world.cfg -workers auto -cleanup hello_world.tla # TLC output: # ... # Model checking completed. No error has been found. TLC should report no error found: this means that NothingUnexpectedInNetwork was also true in every execution. We may be interested to find an execution where Bob becomes happy. We write the invariant . NotBobIsHappy == LET BobIsHappy == bobs_mood = \"happy\" IN ~BobIsHappy . which makes use of the LET keyword, used to define values or operators inline. We use the .cfg file . INIT Init NEXT Next INVARIANTS NotBobIsHappy . We ask TLC to check if ‘always NotBobIsHappy’. If Bob ever becomes happy then it will be false, so TLC will give us a counterexample, or trace, where Bob becomes happy. TLC should spit out a trace . Error: Invariant NotBobIsHappy is violated. Error: The behavior up to this point is: State 1: &lt;..&gt; /\\ network = {} /\\ alices_outbox = {} /\\ bobs_inbox = &lt;&lt;&gt;&gt; /\\ bobs_mood = \"neutral\" State 2: &lt;..&gt; /\\ network = {\"hello\"} /\\ alices_outbox = {\"hello\"} /\\ bobs_inbox = &lt;&lt;&gt;&gt; /\\ bobs_mood = \"neutral\" State 3: &lt;..&gt; /\\ network = {\"hello\", \"world\"} /\\ alices_outbox = {\"hello\", \"world\"} /\\ bobs_inbox = &lt;&lt;&gt;&gt; /\\ bobs_mood = \"neutral\" State 4: &lt;..&gt; /\\ network = {\"world\"} /\\ alices_outbox = {\"hello\", \"world\"} /\\ bobs_inbox = &lt;&lt;\"hello\"&gt;&gt; /\\ bobs_mood = \"neutral\" State 5: &lt;..&gt; /\\ network = {} /\\ alices_outbox = {\"hello\", \"world\"} /\\ bobs_inbox = &lt;&lt;\"hello\", \"world\"&gt;&gt; /\\ bobs_mood = \"neutral\" State 6: &lt;..&gt; /\\ network = {} /\\ alices_outbox = {\"hello\", \"world\"} /\\ bobs_inbox = &lt;&lt;\"hello\", \"world\"&gt;&gt; /\\ bobs_mood = \"happy\" . Notice that bob is happy in state 6. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/hello_world.html#checking-invariants",
    "relUrl": "/docs/tla_basics_tutorials/hello_world.html#checking-invariants"
  },"25": {
    "doc": "Hello World",
    "title": "Wrapping up",
    "content": "This tutorial . | How to read and write simple TLA+ | How to structure models with the (boilerplate, variables, Init, Next, .cfg) pattern | How to think about transitions in terms of (CurrentState, NextState) pairs | How to use actions to specify transitions in the Next operator | How to generate traces matching behaviors using TLC | . That’s it, congratulations :) Try the next tutorial. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/hello_world.html#wrapping-up",
    "relUrl": "/docs/tla_basics_tutorials/hello_world.html#wrapping-up"
  },"26": {
    "doc": "Hello World",
    "title": "Hello World",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/hello_world.html",
    "relUrl": "/docs/tla_basics_tutorials/hello_world.html"
  },"27": {
    "doc": "TLA+ Basics Tutorials",
    "title": "TLA+",
    "content": "These is our basic set of tutorials for TLA+. Please use the cheatsheet too! . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/#tla",
    "relUrl": "/docs/tla_basics_tutorials/#tla"
  },"28": {
    "doc": "TLA+ Basics Tutorials",
    "title": "TLA+ Basics Tutorials",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/",
    "relUrl": "/docs/tla_basics_tutorials/"
  },"29": {
    "doc": "Model Based Testing",
    "title": "Model Based Testing @ Informal Systems",
    "content": "At Informal Systems we aim to incorporate formal methods into everyday development practice. On the practical side, we develop tools and techniques that help developers to increase confidence in their code via automated generation and execution of tests derived from TLA+ models. ",
    "url": "https://mbt.informal.systems/#model-based-testing--informal-systems",
    "relUrl": "/#model-based-testing--informal-systems"
  },"30": {
    "doc": "Model Based Testing",
    "title": "Model Based Testing",
    "content": " ",
    "url": "https://mbt.informal.systems/",
    "relUrl": "/"
  },"31": {
    "doc": "Modelator",
    "title": "Modelator",
    "content": "Modelator is a tool that facilitates generation and execution of tests. Besides other features, it provides: . | easy selection of a model checker to execute (Apalache or TLC) | automatic enumeration of tests in TLA+ files | generation of multiple test executions from the same test assertion | interfaces for execution of generated tests in target languages (currently Rust and Go) | . ",
    "url": "https://mbt.informal.systems/docs/modelator.html",
    "relUrl": "/docs/modelator.html"
  },"32": {
    "doc": "TLA+ cheat sheet",
    "title": "TLA+ Cheatsheet",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html#tla-cheatsheet",
    "relUrl": "/docs/tla_basics_tutorials/tla+cheatsheet.html#tla-cheatsheet"
  },"33": {
    "doc": "TLA+ cheat sheet",
    "title": "TLA+ Quick Start - contains enough to model almost anything",
    "content": "(* Comments *) (* This is multiline comment *) \\* This is single line comment (* Module structure *) ---- MODULE &lt;module&gt; ---- \\* Starts TLA+ module (should be in file &lt;module&gt;.tla) ==== \\* Ends TLA+ module (everything after that is ignored) EXTENDS &lt;module&gt; \\* EXTEND (import) another TLA+ module VARIABLES x, y, ... \\* declares variables x, y, ... CONSTANTS x, y, ... \\* declares constants x, y, ... (should be defined in configuration) Name == e \\* defines operator Name without parameters, and with expression e as a body Name(x, y, ...) == e \\* defines operator Name with parameters x, y, ..., and body e (may refer to x, y, ...) (* Boolean logic *) BOOLEAN \\* the set of all booleans (same as {TRUE, FALSE}) TRUE \\* Boolean true FALSE \\* Boolean false ~x \\* not x; negation x /\\ y \\* x and y; conjunction (can be also put at line start, in multi-line conjunctions) x \\/ y \\* x or y; disjunction (can be also put at line start, in multi-line disjunctions) x = y \\* x equals y x /= y \\* x not equals y x =&gt; y \\* implication: y is true whenever x is true x &lt;=&gt; y \\* equivalence: x is true if and only if y is true (* Integers *) \\* EXTENDS Integers (should extend standard module Integers) Int \\* the set of all integers (an infinite set) 1, -2, 1234567890 \\* integer literals; integers are unbounded a..b \\* integer range: all integers between a and b inclusive x + y, x - y, x * y \\* integer addition, subtraction, multiplication x &lt; y, x &lt;= y \\* less than, less than or equal x &gt; y, x &gt;= y \\* greater than, greater than or equal (* Strings *) STRING \\* the set of all finite strings (an infinite set) \"\", \"a\", \"hello, world\" \\* string literals (can be compared for equality; otherwise uninterpreted) (* Finite sets *) \\* EXTENDS FiniteSets (should extend standard module FiniteSets) {a, b, c} \\* set constructor: the set containing a, b, c Cardinality(S) \\* number of elements in set S x \\in S \\* x belongs to set S x \\notin S \\* x does not belong to set S S \\subseteq T \\* is set S a subset of set T? true of all elements of S belong to T S \\union T \\* union of sets S and T: all x belonging to S or T S \\intersect T \\* intersection of sets S and T: all x belonging to S and T S \\ T \\* set difference, S less T: all x belonging to S but not T {x \\in S: P(x)} \\* set filter: selects all elements x in S such that P(x) is true {e: x \\in S} \\* set map: maps all elements x in set S to expression e (which may contain x) (* Functions *) [x \\in S |-&gt; e] \\* function constructor: maps all keys x from set S to expression e (may refer to x) f[x] \\* function application: the value of function f at key x DOMAIN f \\* function domain: the set of keys of function f [f EXCEPT ![x] = e] \\* function f with key x remapped to expression e (may reference @, the original f[x]) [f EXCEPT ![x] = e1, \\* function f with multiple keys remapped: ![y] = e2, ...] \\* x to e1 (@ in e1 will be equal to f[x]), y to e2 (@ in e2 will be equal to f[y]) [S -&gt; T] \\* function set constructor: set of all functions with keys from S and values from T (* Records *) [x |-&gt; e1, y |-&gt; e2, ...] \\* record constructor: a record which field x equals to e1, field y equals to e2, ... r.x \\* record field access: the value of field x of record r [r EXCEPT !.x = e] \\* record r with field x remapped to expression e (may reference @, the original r.x) [r EXCEPT !.x = e1, \\* record r with multiple fields remapped: !.y = e2, ...] \\* x to e1 (@ in e1 is equal to r.x), y to e2 (@ in e2 is equal to r.y) [x: S, y: T, ...] \\* record set constructor: set of all records with field x from S, field y from T, ... (* Sequences *) \\* EXTENDS Sequences (should extend standard module Sequences) &lt;&lt;a, b, c&gt;&gt; \\* sequence constructor: a sequence containing elements a, b, c s[i] \\* the ith element of the sequence s (1-indexed!) s \\o t \\* the sequences s and t concatenated Len(s) \\* the length of sequence s Append(s, x) \\* the sequence s with x added to the end Head(s) \\* the first element of sequence s (* Tuples *) &lt;&lt;a, b, c&gt;&gt; \\* tuple constructor: a tuple of a,b,c (yes! the &lt;&lt;&gt;&gt; constructor is overloaded) \\* - sequence elements should be same type; tuple elements may have different types t[i] \\* the ith element of the tuple t (1-indexed!) S \\X T \\* Cartesian product: set of all tuples &lt;&lt;x, y&gt;&gt;, where x is from S, y is from T (* Quantifiers *) \\A x \\in S: e \\* for all elements x in set S it holds that expression e is true \\E x \\in S: e \\* there exists an element x in set S such that expression e is true (* State changes *) x', y' \\* a primed variable (suffixed with ') denotes variable value in the next state UNCHANGED &lt;&lt;x,y&gt;&gt; \\* variables x, y are unchanged in the next state (same as x'=x /\\ y'=y) (* Control structures *) LET x == e1 IN e2 \\* introduces a local definition: every occurrence of x in e2 is replaced with e1 IF P THEN e1 ELSE e2 \\* if P is true, then e1 should be true; otherwise e2 should be true . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html#tla-quick-start---contains-enough-to-model-almost-anything",
    "relUrl": "/docs/tla_basics_tutorials/tla+cheatsheet.html#tla-quick-start---contains-enough-to-model-almost-anything"
  },"34": {
    "doc": "TLA+ cheat sheet",
    "title": "Apalache",
    "content": "# Running apalache # A handy alias for calling Apalache alias apalache=\"java -jar apalache-pkg-0.17.5-full.jar --nworkers=8\" # Typecheck apalache typecheck &lt;.tla file&gt; # Model check assuming a .cfg file with the same name as the .tla file is present apalache check &lt;.tla file&gt; # Model check assuming with a specific .cfg file apalache check --config=&lt;.cfg file&gt; &lt;.tla file&gt; # Model check an invariant Foo apalache check --inv=Foo &lt;.tla file&gt; # Generate multiple (up to n) traces for invariant Foo apalache check --view=&lt;View Operator Name&gt; --max-error=n --inv=Foo &lt;.tla file&gt; . (* Writing models with Apalache *) EXTENDS Apalache \\* Import https://github.com/informalsystems/apalache/blob/unstable/src/tla/Apalache.tla \\* Makes Apalache understand that a function with keys in 1.maxSeqLen can be treated as a Sequence FunAsSeq(fn, maxSeqLen) == SubSeq(fn, 1, maxSeqLen) (* Equivalent to the pseudocode: x = initialValue for element in arbitrary_ordering(S): x = CombinerFun(x, element) return x *) FoldSet(CombinerFun, initialValue, S) \\* For a set S (* Equivalent to the pseudocode: x = initialValue for element in sequential_ordering(S): x = CombinerFun(x, element) return x *) FoldSeq(CombinerFun, initialValue, S) \\* For a sequence S . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html#apalache",
    "relUrl": "/docs/tla_basics_tutorials/tla+cheatsheet.html#apalache"
  },"35": {
    "doc": "TLA+ cheat sheet",
    "title": "TLC",
    "content": "# Running TLC # A handy alias providing the JVM with 12GB of RAM (adjust accordingly) and using multiple threads alias tlc=\"java -XX:+UseParallelGC -Xmx12g -cp tla2tools.jar tlc2.TLC -workers auto\" # Model check with TLC tlc -config &lt;.config file&gt; &lt;.tla file&gt; # Run TLC in simulation mode tlc -config &lt;.config file&gt; -simulate &lt;.tla file&gt; . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html#tlc",
    "relUrl": "/docs/tla_basics_tutorials/tla+cheatsheet.html#tlc"
  },"36": {
    "doc": "TLA+ cheat sheet",
    "title": "F.A.Q.",
    "content": "1. Does whitespace matter in TLA+? . Yes whitespace matters when AND’ing (/\\), OR’ing (\\/) . Foo == /\\ x /\\ \\/ y \\/ z . means . Foo == x and ( y or z) . Indentation defines precedence and must be tab or space aligned. The parser should complain if it not aligned. 2. …. coming soon. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html#faq",
    "relUrl": "/docs/tla_basics_tutorials/tla+cheatsheet.html#faq"
  },"37": {
    "doc": "TLA+ cheat sheet",
    "title": "TLA+ cheat sheet",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html",
    "relUrl": "/docs/tla_basics_tutorials/tla+cheatsheet.html"
  },"38": {
    "doc": "Overview",
    "title": "TLA+ Basics Tutorial",
    "content": "This is a straightforward introduction to TLA+. By the end you should be able to write your own models of distributed systems and concurrent algorithms. You should also be able to check properties of the models, and generate execution traces which can be used in automatic testing pipelines. The target audience is software engineers who are fluent in a mainstream programming language and understand computer science. This document contains prose. The cheatsheet is useful as a reference. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tutorial.html#tla-basics-tutorial",
    "relUrl": "/docs/tla_basics_tutorials/tutorial.html#tla-basics-tutorial"
  },"39": {
    "doc": "Overview",
    "title": "TLA+ capabilities",
    "content": "TLA+ is a language for writing models of distributed systems and concurrent algorithms. It doesn’t execute on your machine like a typical programming language: you run it through a model checker. A model checker is a program that explores all possible executions of a system. You can specify properties and behaviors, and the model checker will tell you if they hold or not. The model checker can also give you examples of behaviors. TLA+ has been used to model a wide variety of things including locks and allocators in the linux kernel, the Docker SwarmKit container orchestrator, Paxos consensus, the Raft replicated state machine and more. All TLA+ models are structured as a state machine. You specify an initial state and a collection of transitions. Additionally you can specify boolean functions (invariants) over the state. The model checker will check for boolean function violations. To give examples: you could model a concurrent garbage collector algorithm and check that no memory leak is possible. You could also model the API for a financial transfers system, and check that it is not possible to steal funds. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tutorial.html#tla-capabilities",
    "relUrl": "/docs/tla_basics_tutorials/tutorial.html#tla-capabilities"
  },"40": {
    "doc": "Overview",
    "title": "Getting set up",
    "content": "For these tutorials we require the TLC and Apalache model checkers. TLC can be downloaded with . tlaurl=https://github.com/tlaplus/tlaplus/releases/download/v1.7.1/tla2tools.jar; curl -LO $tlaurl; . Apalache can be downloaded with . apalacheurl=https://github.com/informalsystems/apalache/releases/download/v0.17.5/apalache-v0.17.5.zip; curl -LO $apalacheurl; . You will need to unzip Apalache and move the jar from mod-distribution/target/apalache-pkg-0.17.5-full.jar to your working directory. We recommend using the Visual Studio Code TLA+ extension to work on your models. It provides syntax highlighting, parsing and model checking through TLC. Model checking, parsing and other features are accessed through the VSCode context menu (cmd + shift + p on OSX). There are more resources that we won’t in this set of tutorials but that might be useful to know about. Please see The TLA+ ecosystem. The .tla and other files referenced in these tutorials are included here. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tutorial.html#getting-set-up",
    "relUrl": "/docs/tla_basics_tutorials/tutorial.html#getting-set-up"
  },"41": {
    "doc": "Overview",
    "title": "Let’s get started",
    "content": "We have 5 mini tutorials giving you increasing power. | ‘Hello world’ using TLC | Typechecking your models | Apalache vs TLC | Finding an Ethereum exploit using Apalache | Generating traces for automated testing using Apalache | . That’s it for the basic tutorials; congratulations! . These tutorials make up the basics of using TLA+, please see advanced tutorials! . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tutorial.html#lets-get-started",
    "relUrl": "/docs/tla_basics_tutorials/tutorial.html#lets-get-started"
  },"42": {
    "doc": "Overview",
    "title": "Footnote: what the tutorials do not include",
    "content": "TLA+ and its tools includes many features. We ignored the following in these basic tutorials . | Formal proof using TLAPS | Inductive invariants using Apalache | Verifying temporal (liveness) properties [1, 2] | TLC’s symmetry sets and model values | Apalache’s uninterpreted types | . These features are useful in some circumstances. We may add sections in the future. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tutorial.html#footnote-what-the-tutorials-do-not-include",
    "relUrl": "/docs/tla_basics_tutorials/tutorial.html#footnote-what-the-tutorials-do-not-include"
  },"43": {
    "doc": "Overview",
    "title": "Overview",
    "content": " ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/tutorial.html",
    "relUrl": "/docs/tla_basics_tutorials/tutorial.html"
  },"44": {
    "doc": "Typechecking",
    "title": "Typechecking",
    "content": "The .tla and other referenced files are included here. As a model grows it becomes difficult to ensure that the TLA+ code in the models is doing what you think it is. There are techniques to help ensure there are no bugs in your model. The best way to make sure your model is high quality is to use types and the Apalache type checker. Apalache comes with a type checker. The docs contain all the details. In this tutorial we will type the model of Alice and Bob’s interactions in hello_world.tla. We will use a subset of the built in types. The full list of builtin types can be found here. ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/typechecking.html",
    "relUrl": "/docs/tla_basics_tutorials/typechecking.html"
  },"45": {
    "doc": "Typechecking",
    "title": "Typechecking",
    "content": "Our model of Alice and Bob’s interaction is simple: the state variables are simple data structures. We should type the variables with a particular data structure. VARIABLES \\* @type: Set(Str); alices_outbox, \\* @type: Set(Str); network, \\* @type: Str; bobs_mood, \\* @type: Seq(Str); bobs_inbox . The Apalache type system works by annotating lines of code with special TLA+ comments . \\* @type: ... We have specified that . | alices_outbox is a set of strings | network is a set of strings | bobs_mood is a string | bobs_inbox is a sequence of strings | . We can also specify the type of operators. For example we can annotate AliceSend(m) . \\* @type: (Str) =&gt; Bool; AliceSend(m) == /\\ m \\notin alices_outbox /\\ alices_outbox' = alices_outbox \\union {m} /\\ network' = network \\union {m} /\\ UNCHANGED &lt;&lt;bobs_mood, bobs_inbox&gt; . The annotation says that AliceSend is an operator taking strings and returning booleans. (Note that very often the typechecker can infer annotations for operators automatically. It is able to do so for the operator AliceSend, too. You can try typechecking with the manual annotation left out.) . Finally we can typecheck the model . java -jar apalache-pkg-0.17.5-full.jar typecheck hello_world_typed.tla # Apalache output: # ... # Type checker [OK] . ",
    "url": "https://mbt.informal.systems/docs/tla_basics_tutorials/typechecking.html",
    "relUrl": "/docs/tla_basics_tutorials/typechecking.html"
  }
}
